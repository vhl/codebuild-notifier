#!/usr/bin/env ruby

# codebuild-notifier
# Copyright © 2018 Adam Alboyadjian <adam@cassia.tech>
# Copyright © 2018 Vista Higher Learning, Inc.
#
# codebuild-notifier is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# codebuild-notifier is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with codebuild-notifier.  If not, see <http://www.gnu.org/licenses/>.

require 'codebuild-notifier'
require 'optparse'
# This script updates a DynamoDb table with the last codebuild build status
# for the current project and branch or pr. If the current build status is
# different from the previous status, the email address of the author of the
# last commit is extracted from the git commit, and a notification is sent
# via slack.

def quit(message)
  cb_puts(message)
  exit
end

def cb_puts(message)
  puts "CODEBUILD NOTIFIER: #{message}"
end

def not_latest_commit_in_branch_message(build, config)
  "Commit #{build.commit_hash} in project #{build.project_code} did " \
  'not match the most recent commit for any Pull Requests or the ' \
  "whitelisted branches: #{config.whitelist}. Skipping status updates."
end

def not_pr_or_whitelisted_branch_message(config)
  'Build is neither for a Pull Request nor for one of whitelisted ' \
  "branches: #{config.whitelist}. Skipping status updates."
end

def no_status_diff_message(build)
  "Current status #{build.status} is same as last status. " \
  'Skipping slack notifications.'
end

command_line_opts = {}

# rubocop:disable Metrics/BlockLength
OptionParser.new do |opts|
  opts.banner = 'Usage: update-build-status [OPTIONS]'

  opts.on(
    '--additional-channel=CHANNEL',
    'status notifications for whitelisted branches will be sent here ' \
    'as well as to author/committer'
  ) { |usernames| command_line_opts[:slack_admin_users] = usernames }

  opts.on(
    '--default-notify-strategy=STRATEGY',
    'when to send notifications, in the absence of a branch-specific ' \
    'override -- valid options are: status_change (the default), ' \
    'every_build, every_failure_and_status_change'
  ) { |default_strategy| command_line_opts[:default_strategy] = default_strategy }

  opts.on(
    '--dynamo-table=TABLE',
    'table for storing build statuses'
  ) { |table| command_line_opts[:dynamo_table] = table }

  opts.on(
    '--notify-every-build-branches=BRANCHES',
    'allows branch-specific override for default notify strategy; ' \
    'comma-separated list of branches that will have build notifications ' \
    'sent for every build, regardless of previous build status'
  ) { |branches| command_line_opts[:notify_every_build_branches] = branches }

  opts.on(
    '--slack-admin-usernames=USERS',
    'comma-separated list of slack users to be notified if build status ' \
    'notifications fail to send'
  ) { |usernames| command_line_opts[:slack_admin_users] = usernames }

  opts.on(
    '--slack-secret-name=SECRET',
    'name of Secrets Manager secret with slack app/bot auth token'
  ) { |slack_secret| command_line_opts[:slack_secret_name] = slack_secret }

  opts.on(
    '--whitelist-branches=BRANCHES',
    'comma-separated list of branches that will have build notifications ' \
    'sent even if there is no open Pull Request'
  ) { |whitelist| command_line_opts[:whitelist_branches] = whitelist }

  opts.on('--region=REGION', 'AWS region') do |region|
    command_line_opts[:region] = region
  end
end.parse!
# rubocop:enable Metrics/BlockLength

config = CodeBuildNotifier::Config.new(command_line_opts)
build = CodeBuildNotifier::CurrentBuild.new
history = CodeBuildNotifier::BuildHistory.new(config, build)

last_build = history.last_entry

if build.launched_by_retry?
  # Whenever a build is triggered by a PR or whitelisted branch, we update
  # the record for that trigger with the commit hash. If a build is then
  # launched using Retry, the status is updated and are notifications sent
  # only if the re-tried build was for the latest commit. Otherwise re-trying
  # an older commit could result in inaccurate notifications.
  quit(not_latest_commit_in_branch_message(build, config)) unless last_build

  source_id = last_build.source_id
  source_ref = last_build.source_ref
else
  # We only want to track information for whitelisted branches and branches
  # with open Pull Requests.
  unless config.non_pr_branch_ids.include?(build.trigger) || build.for_pr?
    quit(not_pr_or_whitelisted_branch_message(config))
  end
  source_id = build.source_id
  source_ref = build.trigger
end

# Update record for this project + branch/pr in DynamoDb even if the
# status hasn't changed, so the latest commit hash is stored.
history.write_entry(source_id) do |new_item|
  cb_puts "Updating dynamo table #{config.dynamo_table} with: #{new_item}"
end

status_changed = last_build&.status != build.status
unless config.notify_every_build_branch_ids.include?(build.trigger)
  if config.default_strategy == 'status_change'
    quit(no_status_diff_message(build)) unless status_changed
  elsif config.default_strategy == 'fail_or_status_change'
    # TODO: Find good wording for a different exit message for this case.
    quit(no_status_diff_message(build)) if build.status == 'SUCCEEDED' && !status_changed
  end
end

slack_message = CodeBuildNotifier::SlackMessage.new(build, config, source_ref)
sender = CodeBuildNotifier::SlackSender.new(config)
sender.send(slack_message)
