#!/usr/bin/env ruby

require 'codebuild-notifier'
require 'optparse'
# This script updates a DynamoDb table with the last codebuild build status
# for the current project and branch or pr. If the current build status is
# different from the previous status, the email address of the author of the
# last commit is extracted from the git commit, and a notification is sent
# via slack.

def quit(message)
  cb_puts(message)
  exit
end

def cb_puts(message)
  puts "CODEBUILD NOTIFIER: #{message}"
end

def not_latest_commit_in_branch_message(build, config)
  "Commit #{build.commit_hash} in project #{build.project_code} did " \
  'not match the most recent commit for any Pull Requests or the ' \
  "whitelisted branches: #{config.whitelist}. Skipping status updates."
end

def not_pr_or_whitelisted_branch_message(config)
  'Build is neither for a Pull Request nor for one of whitelisted ' \
  "branches: #{config.whitelist}. Skipping status updates."
end

def no_status_diff_message(build)
  "Current status #{build.status} is same as last status. " \
  'Skipping slack notifications.'
end

command_line_opts = {}

# rubocop:disable Metrics/BlockLength
OptionParser.new do |opts|
  opts.banner = 'Usage: update-build-status [OPTIONS]'

  opts.on(
    '--additional-channel=CHANNEL',
    'status notifications for whitelisted branches will be sent here ' \
    'as well as to author/committer'
  ) { |usernames| command_line_opts[:slack_admin_users] = usernames }

  opts.on(
    '--slack-admin-usernames=USERS',
    'comma-separated list of slack users to be notified if build status ' \
    'notifications fail to send'
  ) { |usernames| command_line_opts[:slack_admin_users] = usernames }

  opts.on(
    '--dynamo-table=TABLE',
    'table for storing build statuses'
  ) { |table| command_line_opts[:dynamo_table] = table }

  opts.on(
    '--slack-secret-name=SECRET',
    'name of Secrets Manager secret with slack app/bot auth token'
  ) { |slack_secret| command_line_opts[:slack_secret_name] = slack_secret }

  opts.on(
    '--whitelist-branches=BRANCHES',
    'comma-separated list of branches that will have build notifications ' \
    'sent even if there is no open Pull Request'
  ) { |whitelist| command_line_opts[:whitelist_branches] = whitelist }

  opts.on('--region=REGION', 'AWS region') do |region|
    command_line_opts[:region] = region
  end
end.parse!
# rubocop:enable Metrics/BlockLength

config = CodeBuildNotifier::Config.new(command_line_opts)
build = CodeBuildNotifier::CurrentBuild.new
history = CodeBuildNotifier::BuildHistory.new(config, build)

last_build = history.last_entry

if build.launched_by_retry?
  # Whenever a build is triggered by a PR or whitelisted branch, we update
  # the record for that trigger with the commit hash. If a build is then
  # launched using Retry, the status is updated and are notifications sent
  # only if the re-tried build was for the latest commit. Otherwise re-trying
  # an older commit could result in inaccurate notifications.
  quit(not_latest_commit_in_branch_message(build, config)) unless last_build

  source_id = last_build.source_id
  source_ref = last_build.source_ref
else
  # We only want to track information for whitelisted branches and branches
  # with open Pull Requests.
  unless config.non_pr_branch_ids.include?(build.trigger) || build.for_pr?
    quit(not_pr_or_whitelisted_branch_message(config))
  end
  source_id = build.source_id
  source_ref = build.trigger
end

# Update record for this project + branch/pr in DynamoDb even if the
# status hasn't changed, so the latest commit hash is stored.
history.write_entry(source_id) do |new_item|
  cb_puts "Updating dynamo table #{config.dynamo_table} with: #{new_item}"
end

quit(no_status_diff_message(build)) if last_build&.status == build.status

slack_message = CodeBuildNotifier::SlackMessage.new(build, config, source_ref)
sender = CodeBuildNotifier::SlackSender.new(config)
sender.send(slack_message)
