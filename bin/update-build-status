#!/usr/bin/env ruby

require 'aws-sdk-dynamodb'
require 'aws-sdk-secretsmanager'
require 'slack-ruby-client'

class Notifier
  include CodeBuildNotifier::Environment

  # This script updates a DynamoDb table with the last codebuild build status
  # for the current project and branch or pr. If the current build status is
  # different from the previous status, the email address of the author of the
  # last commit is extracted from the git commit, and a notification is sent
  # via slack.

  def run
    build_store = CodeBuildNotifier::BuildStatusStorage.new

    # If trigger is empty, this build was launched using the Retry command from
    # the console or api, so we don't have a pr or branch name in the env vars.
    # The commit hash and project code are used to find which pr or branch this
    # commit belongs to, and its previous status.
    if trigger.empty?
      last_build = build_store.last_build_by_hash

      # Whenever a build is triggered by a PR or whitelisted branch, we update
      # the record for that trigger with the commit hash. If a build is then
      # launched using Retry, the status is updated, and notifications sent,
      # only if the re-tried build was for the latest commit. Otherwise re-trying
      # an older commit could result in inaccurate notifications.
      unless last_build
        cb_puts "Commit #{commit_hash} in project #{project_code} did not match " \
                'the most recent commit for any Pull Requests or the whitelisted ' \
                "branches: #{whitelist}. Skipping status updates."
        exit
      end
    else
      # We only want to track information for branches with open PRs, except for
      # master and release branches.
      unless non_pr_branches.include?(trigger) || trigger =~ %r{^pr/}
        cb_puts 'Build is neither for a Pull Request nor for one of whitelisted ' \
                "branches: #{whitelist}. Skipping status updates."
        exit
      end

      last_build = build_store.last_build_by_trigger
    end

    # Update record for this project + branch/pr in DynamoDb even if the
    # status hasn't changed, so the latest commit hash is stored.
    build_store.write_build

    if last_build&.status == current_status
      cb_puts "Current status #{current_status} is same as last status." \
              'Skipping slack notifications.'
      exit
    end

    ## Extraction target: message formatter
    # gets 5 values from git
    # needs source_ref, current_status, git_repo, commit_hash, project_code
    git_info = `git show -s --format='%h|%aN|%aE|%cE|%s'`.chomp.split('|')

    short_hash, author_name, author_email, committer_email, commit_subject = git_info

    users_to_notify = [author_email, committer_email].uniq

    commit_link = "<#{git_repo}/commit/#{commit_hash}|#{short_hash}>"

    title = "#{slack_icon} #{author_name}'s " \
            "<#{details_url}|#{project_code} build> - " \
            "#{current_status.downcase}"
    message = "commit #{commit_link} (#{commit_subject}) in " \
              "#{source_ref_link(build_store.source_ref)}"

    # extraction target:
    # Slack client. Pass in region, secrets_manager_slack_secret_name comes
    # from env.
    # Expose notify method that takes array of email addresses.
    secrets_client = Aws::SecretsManager::Client.new(region: region)
    secret = secrets_client.get_secret_value(
      secret_id: secrets_manager_slack_secret_name
    )

    app_token = JSON.parse(secret.secret_string)['token']
    Slack.configure do |config|
      config.token = app_token
    end

    # If the app token starts with xoxb- then it is a Bot User Oauth token
    # and slack notifications should be posted with as_user: true. If it
    # starts with xoxp- then it's an app token not associated with a user,
    # and as_user: should be false.
    is_bot_user = /\Axoxb/.match?(app_token)

    slack_client = Slack::Web::Client.new

    users_to_notify.each do |email|
      lookup_response = slack_client.users_lookupByEmail(email: email)

      if lookup_response.ok
        slack_user_id = lookup_response.user.id

        slack_client.chat_postMessage(
          as_user: is_bot_user,
          attachments: [
            {
              color: slack_color,
              fallback: [title, message].join("\n"),
              title: title,
              text: message
            }
          ],
          channel: slack_user_id
        )
      else
        cb_puts "Slack user lookup by email for #{email} failed with " \
                "error: #{lookup_response.error}"
      end
    end
  end

  private def cb_puts(message)
    puts "CODEBUILD NOTIFIER: #{message}"
  end

  private def details_url
    'https://console.aws.amazon.com/codesuite/codebuild/projects/' \
    "#{project_code}/build/#{build_id}/log?region=#{region}"
  end

  private def source_ref_link(source_ref)
    url_path = if %r{\Apr/}.match?(source_ref)
                 "pull/#{source_ref[3..-1]}"
               else
                 "tree/#{source_ref.gsub(%r{\Abranch/}, '')}"
               end
    "<#{git_repo}/#{url_path}|#{source_ref}>"
  end

  private def slack_color
    {
      'FAILED' => 'danger',
      'SUCCEEDED' => 'good'
    }[current_status]
  end

  private def slack_icon
    {
      'FAILED' => ':broken_heart:',
      'SUCCEEDED' => ':green_heart:'
    }[current_status]
  end

  private def non_pr_branches
    whitelisted_branches.map do |branch_name|
      "branch/#{branch_name}"
    end
  end

  private def whitelist
    whitelisted_branches.join(', ')
  end
end

Notifier.new.run
